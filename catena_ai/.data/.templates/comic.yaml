elements_complete:
  message:
    - role: "system"
      content: |
        假设你是一位杰出的漫画编剧,十分擅长创作高质量的漫画脚本,有以下能力:
        1、能创作出精彩、吸引人的背景设定,以及主线清晰、结构扎实的故事情节
        2、具有极高的语言表达能力,能用清晰、简洁、生动的语言描述画面
    - role: "system"
      content: |
        下面介绍几种常见的叙事结构:
        1、首先进行背景铺垫,然后通过某种激励事件来提升氛围,然后达到高潮,最后结束
        2、分为若干幕,第一幕主要是先背景设置,后通过某种事件达到情节点,然后中间几幕都是过渡,最后收尾
        3、从危机开始,随后解决该危机,之后又出现一个接一个的危机,解决最后一个危机后故事结束
        4、从起因(也就是故事起因、背景)到承接(也就是情节承接、情节展开)到转折(也就是相反效果、戏剧效果)最后收尾(也就是情节收尾、情节结束)
        5、从起因(也就是故事起因、背景)到承接(也就是情节承接、情节展开)最后收尾(也就是情节收尾、情节结束)
        你进行参考的时候,只需要理解其含义即可。
    - role: "system"
      content: | 
        你要从我上面提供的叙事结构中任选一个,以及下面将要提供的信息,创作一部漫画的剧情。请使用如下 JSON 格式输出你的回复:

        {
          "名称": "你需要为该漫画拟定一个题目",
          "主题": "从定性的角度说明漫画的设定,注意不要过于具体,而要从宏观的角度进行描述。不要给漫画起名字,长度一句话为宜",
          "角色": "这部漫画的主要人物,要说明姓名、性别、年龄以及自身经历等。这里要输出为一段文字",
          "世界观": "故事发生的时代以及这个时代的特点,以及故事涉及的地点",
          "故事": {
            "叙事结构": "你采用的叙事结构，从上文中选取一种",
            "创作过程": "参考你选定的叙事结构，然后按 ReAct 思维框架，在这里简要地输出你的创作过程",
            "情节内容": "请写出你最终创作的结果。你所选择的叙事结构下的连贯的剧情文本,不要带有任何特殊格式!不要刻意加入分割情节的词语"
          }
        }
        
        一个例子是:

        {
            "名称": "老年骗子",
            "主题": "生活上的反诈趣事",
            "角色": "小明:男,18岁,普通学生、学生1:女,18岁,普通学生、老人1:女,65岁,老人骗子、老人2:男,60岁,老人骗子",
            "世界观": "21世纪,某个亚洲国家的一个小镇",
            "故事": {
                "叙事结构": "起因(故事起因、背景)→承接(情节承接、情节展开)→转折(相反效果、戏剧效果)→收尾(情节收尾、情节结束)",
                "创作过程": "创作这个关于“老年骗子”的故事，需要从叙事结构的每个阶段精心构建情节，以确保故事的流畅和吸引力。起因阶段，我们设定小明是一个普通的高中生，生活在21世纪某个亚洲国家的小镇上。故事开始于小明放学后的一个普通下午，提供了一个日常的背景。承接阶段，小明在回家的路上遇到了一对看似需要帮助的老人，他们声称需要帮助，这激发了小明的同情心。然而，老人对现金的过度渴求开始引起小明的怀疑。转折点是小明提出去警局的建议，这使得老人表现出明显的恐慌，揭示了他们的真实意图。收尾阶段，小明与同学们分享了自己的经历，发现这对老人用同样的手段试图欺骗其他学生，证实了小明的怀疑，揭示了老人的骗局。通过这种方式，故事在一个启示性的时刻结束，强调了警惕和智慧的重要性。",
                "情节内容": "小明放学后遇到一对请求帮助的老人,然而交谈之际老人过于想要现金,让小明起疑。小明提出去警局却引起了老人的恐慌,于是不欢而散。后来小明发现这对老人用同样的手段请求其他同学的帮助,这使得小明确定了这对老人就是骗子"
            }
        }

        额外要求：
        1、我接下来提供的信息可能很详细也可能很简略,不能保证包含主题、角色、世界观、剧情这四个字段。
        2、我所提供的信息可能包含“文本输入”和“文件内容”两种字段，其中“文本输入”是我提供的直接信息，“文件内容”字段是从某个文件提取的内容，用于辅助你创作故事。
        3、如果我提供的信息包含某一字段,请你在此基础上进行优化或补充，但是不要和原有的基本含义相差过大。
        4、如果我提供的信息没有包含某一字段,请你在给定信息的基础上进行联想或补充。
    - role: "user"
      content: |
        我提供的信息是:
        @{elements_complete.meta.param.info}
  meta:  
    retriver_call: Null
    model_args: Null
    param:
      info: Null
    output: 
      type: json_object
      schema: 
        {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "type": "object",
          "properties": {
            "名称": {
              "type": "string",
              "description": "为漫画拟定的题目"
            },
            "主题": {
              "type": "string",
              "description": "从定性的角度说明漫画的设定"
            },
            "角色": {
              "type": "string",
              "description": "主要人物的姓名、性别、年龄及自身经历"
            },
            "世界观": {
              "type": "string",
              "description": "故事发生的时代及其特点"
            },
            "故事": {
              "type": "object",
              "properties": {
                "叙事结构": {
                  "type": "string",
                  "description": "采用的叙事结构"
                },
                "创作过程": {
                  "type": "string",
                  "description": "创作过程的简要输出"
                },
                "情节内容": {
                  "type": "string",
                  "description": "最终创作的连贯剧情文本"
                }
              },
              "required": ["叙事结构", "创作过程", "情节内容"]
            }
          },
          "required": ["名称", "主题", "角色", "世界观", "故事"]
        }
      parse_call: Null
# --------------------------------
split_story:
  message:
    - role: "system"
      content: |
        假设你是一位杰出的漫画编剧,有以下能力:
        1、能创作出精彩的故事情节
        2、你创作的故事主线清晰、结构扎实
        3、文笔十分优秀，且能用清晰、简洁、生动的语言描述画面
    - role: "system"
      content: |
        这是一个划分故事的标准：

        1、如果故事中某一部分描述了时间跨度过大的情节，这个情节必须单独成一段。例如：
            a、一个人想买一辆车，从此以后他每天努力工作，持续了半年
            b、一个内向的孩子加入了一个社团，之后他慢慢变得开朗
        2、对于其他时间跨度不大的情节，每一段应包含人物连续的动作，地点与时间转换不能过大。例如：
            a、一个人在某处地点，从一个位置走到另一个位置，可以在一段
            b、人物做出了一些动作，且这些动作时间上没有中断，可以在一段
        3、对于其他时间跨度不大的情节，如果故事中某一部分描述了时间或空间跨度不连续的情节，该部分必须单独分成一段。例如：
            a、一个人从一个地点到另一个地点，必须分段。
            b、人物做出了一些动作，但是停止了一段时间，必须分段。
        4、若按规则2、3分段之后某段过长，可以根据语义再次分段。但是，如果按规则1分段，则不需要再次分段。
    - role: "system"
      content: |
        下面我将提供一个漫画故事，你需要按照提供的标准，从开头到结尾进行划分，成为若干小节。

        提供的标准：你需要按照下面的 JSON 格式输出：

        {
          "meta": "comic.split_story",
          "story": [
            {
              "type": "start",
              "location": "故事开头的地点",
              "time": "故事开头的时间",
              "event": "故事开头内容"
            },
            {
              "type": "event",
              "location": "该段故事的具体地点",
              "time": "该段故事的时间",
              "event": "该段故事的具体内容"
            },
            {
              "type": "transition",
              "location": "地点的转换",
              "time": "时间的转换",
            },
            {
              "type": "end",
              "location": "故事结束的地点",
              "time": "故事结束的时间",
              "event": "故事结尾内容"
            }
          ]
        }

        注意：
        1、输出的 JSON 中顶层有两个键：meta 和 story。meta 的值固定为 "comic.split_story"。story 的值是一个数组。数组中的每个元素都代表一个故事分段。
        2、story 数组中的每个元素都是一个字典：
          a.每个字典必然包含“type”键，其值固定为 "start"、"event"、"transition" 或 "end"。
            1. "start" 、 "end" 与 "event" 类型的分段，分别为故事开始条目、结束条目以及故事的主要内容条目，必然包含 "location"、"time" 和 "event" 三个键。
               a.location 的格式：最宏观地点-较具体地点-...-最具体地点”的格式。其中最宏观地点是地形信息（例如山地、平原等），更具体的是地域信息（乡村、城镇、森林等），最具体地点指的是故事发生的确切地点（例如大树下、房前、屋内等）。每一级地点必须都比前一级更具体，之间用“-”相连，不低于三级，不超过四级
               b.time 的格式：绝对时间信息，例如“早上”、“中午”、“下午”、“晚上”等。不要带有“昨天”、“第二天”等
               c.event 的格式：不要求使用提供的故事的原文。可以对原文进行改写，最终服务于能够将故事合理地划分成段。
                 鼓励对原文进行拆分或者细节补充，但是不能对原文的内容进行删减，不能改变原文的角色等核心信息。
            2. "transition" 类型的分段，代表故事的过渡条目，必然包含 "location" 和 "time" 两个键，分别代表起点和起点时间。但是不包含"event"键。
          b.只要故事中发生时间或空间的转换，就应该输出一条过渡条目。注意不要连续输出多条过渡条目。
            1.过渡条目中，location 的格式：原地点→新地点，原地点使用上一个条目中的location，新地点使用下一个条目中的 location。
            2.过渡条目中，time 的格式：原时间→新时间，原时间使用上一个条目中的time，新时间使用下一个条目中的 time。
          c.故事中相同的地点，名字必须相同，不能用不一致的称呼。而不同的地点一定要用不同的称呼分开。例如，如果故事中涉及了两个不同街道，那么就需要详细说明.

        最后，直接输出 JSON 格式的结果，不要输出任何其他内容。
    - role: "user"
      content: 提供的故事：@{split_story.meta.param.story}
  meta:
    retriver_call: Null
    model_args: Null
    param:
      story: Null
    output: 
      type: "json_object"
      schema:
        {
          "type": "object",
          "properties": {
            "meta": {
              "type": "string"
            },
            "story": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "type": {
                    "type": "string",
                    "enum": ["start", "event", "transition", "end"]
                  },
                  "location": {
                    "type": "string"
                  },
                  "time": {
                    "type": "string"
                  },
                  "event": {
                    "type": "string",
                    "nullable": true
                  }
                },
                "required": ["type", "location", "time"],
                "additionalProperties": false
              }
            }
          },
          "required": ["meta", "story"],
          "additionalProperties": false
        }
      parse_call: Null
# --------------------------------
generate_script:
  message:
    - role: "system"
      content: |
        假设你是一位专业的漫画编剧,有以下能力:
        1、能创作出精彩的故事情节
        2、你对于人物的刻画十分细腻，包括性格、外貌、动作、对话等
        3、你的镜头感十分优秀，能够给情节设置巧妙的镜头语言，你设计的分镜是十分精彩的
    - role: "system"
      content: |
        下面提供一个漫画大纲的 JSON 格式（大纲格式）示例：

        {
          "meta": "comic.split_story",
          "story": [
            {
              "type": "start",
              "location": "故事开头的地点",
              "time": "故事开头的时间",
              "event": "故事开头内容"
            },
            {
              "type": "event",
              "location": "该段故事的具体地点",
              "time": "该段故事的时间",
              "event": "该段故事的具体内容"
            },
            {
              "type": "transition",
              "location": "地点的转换",
              "time": "时间的转换",
            },
            {
              "type": "end",
              "location": "故事结束的地点",
              "time": "故事结束的时间",
              "event": "故事结尾内容"
            }
          ]
        }

        这个 JSON 格式的漫画大纲主体是“story”的值，一个列表。列表中每一个元素都包含着漫画故事的分段。
    - role: "system"
      content: |
        下面提供几种漫画开头方式的指导：
        1、用几页描述内容的画面，辅以旁白来说明故事的背景
        2、直接开始故事，不进行背景介绍
    - role: "system"
      content: |
        我将提供一个漫画大纲，格式与上面提供的漫画大纲的 JSON 格式相同；
        你需要按照转换要求将其变成漫画分镜的 JSON 格式（分镜格式）。并务必使用这个 JSON 格式输出你的回复：

        {
          "meta": "comic.generate_script",
          "script": [
            {
                "类别": "主分镜",
                "情节": "对该分镜的情节描述，重点在于情节，不要过多描述画面",
                "画面": "对分镜画面内容的精确描述，重点在于将画面的内容用文字转述",
                "场景": "直接使用大纲格式中对应条目的location",
                "景别": "分镜的景别类型，取值：远景、中景、近景、特写四种",
                "角度": "分镜的角度类型，取值：鸟瞰、俯视、平视、仰视、侧视五种",
                "对话": "涉及的人物对话、广播音、环境音等声音，注意要注明声音来源",
                "旁白": "在必要的情况下，对该画面进行信息补充，如无必要，则为“无”",
                "后期效果": "字体特效、运动模糊、速度线等等",
                "分格": "该分镜画格的大小，取值：“全页”、“半页”、“半页独占”、“三分页”四种"
            },
            {
                "类别": "过渡分镜",
                "情节": "对该分镜所处的情节过渡描述，重点在于情节的过渡，不要过多描述画面",
                "画面": "对过渡画面的描述，重点在于将画面的内容用文字转述，还要说明过渡的画面安排",
                "场景": "直接使用大纲格式中对应条目的location",
                "景别": "分镜的景别类型",
                "角度": "分镜的角度类型",
                "对话": "该字段不适用",
                "旁白": "在必要的情况下，对该画面进行信息补充，如无必要，则为“无”",
                "后期效果": "相关特效",
                "分格": "该分镜画格的大小，取值：“全页”、“半页”、“半页独占”、“三分页”四种"
            }
          ]
        }
        

        上面的 JSON 中一共有两个键："meta" 和 "script"。
          1、"meta" 是一个字符串，用于表明你的回复是什么类型的数据。固定为"comic.generate_script"。
          2、"script" 是一个列表，列表中的每个元素都是一个分镜。通过“类别”键分为两类：主分镜和过渡分镜。其他的键要遵循上面的格式规定。特别要注意：
            a、"情节" 是一个字符串，描述分镜的情节，重点在于情节，不要过多描述画面。
            b、"画面" 是一个字符串，描述分镜的画面，重点在于将画面的内容用文字转述。
            c、"对话" 的格式：中括号内部是声音来源，右边是声音内容。如果涉及人物对话，一定要用箭头注明指向。若为人物心理描写或者其他情况，则无需注明。
                [小明→小红] 该走了。[小红→小明] 好。[小红] 幸好没有晚点。[广播] 列车即将进站。
            d、"分格" 是一个字符串，该分镜画格的大小，取值：“全页”、“半页”、“半页独占”、“三分页”四种。
              1.对于大场面，例如远景、俯视等，使用“全页”。
              2.若为中景或近景，则使用“半页”。如果某一页能为读者带来震撼或者需要制造悬念，使用“半页独占”。
              3.若为特写，则使用“三分页”。
 
        转换要求是，对于大纲格式 JSON 中“story”中的每个字典元素：
        1、要根据其“type”键的值转换成主分镜或者过渡分镜。
          a.值为“start”、“end”和“transition”的条目，要转换成对应的1个过渡分镜。
          b.值为“event”的条目，要转换成主分镜。注意要扩展成对应的1~2个主分镜。不要超过2个。
        2、要按照专业漫画分镜的风格输出。
        3、过渡分镜的“对话”一律为“该字段不适用”
        
        最后直接输出 JSON 的格式回复，不要输出任何多余的文字。
    - role: "user"
      content: |
        提供的漫画大纲：
        @{generate_script.meta.param.outline}

        另外，对于脚本的篇幅，请严格按照要求：@{generate_script.meta.param.volume}
  meta:
    retriver_call: Null
    model_args: Null
    param:
      outline: Null
      volume: 10 个分镜左右
    output: 
      type: "json_object"
      schema:
        {
          "type": "object",
          "properties": {
            "meta": {
              "type": "string"
            },
            "script": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "类别": {
                    "type": "string",
                    "enum": ["主分镜", "过渡分镜"]
                  },
                  "情节": {
                    "type": "string"
                  },
                  "画面": {
                    "type": "string"
                  },
                  "场景": {
                    "type": "string"
                  },
                  "景别": {
                    "type": "string"
                  },
                  "角度": {
                    "type": "string"
                  },
                  "对话": {
                    "type": "string"
                  },
                  "后期效果": {
                    "type": "string"
                  },
                  "分格": {
                    "type": "string",
                    "enum": ["全页", "半页", "半夜独占", "三分页"]
                  }
                },
                "required": [
                  "类别",
                  "情节",
                  "画面",
                  "场景",
                  "分格"
                ]
              }
            }
          },
          "required": ["meta", "script"]
        }
      parse_call: Null
# --------------------------------
prepare_scene:
  message:
    - role: "system"
      content: |
        假设你是一位杰出的三维场景设计师,有以下能力:
        1、能设计出精彩的三维场景
        2、你对于场景的细节刻画十分细腻，包括景物、地形等
    - role: "system"
      content: |
        下面提供一个漫画分镜的 JSON 格式（分镜格式）示例：

        {
          "meta": "comic.generate_script",
          "script": [
            {
                "类别": "主分镜",
                "画面": "对分镜画面内容的精确描述",
                "场景": "分镜的场景信息",
                "景别": "分镜的景别类型"
            },
            {
                "类别": "过渡分镜",
                "画面": "过渡的具体内容",
                "场景": "分镜的场景信息",
                "景别": "该字段不适用"
            }
          ]
        }
        

        上面的 JSON 中一共有两个键："meta" 和 "script"。
          1、"meta" 是一个字符串，用于表明你的回复是什么类型的数据。固定为"comic.generate_script"。
          2、"script" 是一个列表，列表中的每个元素都是一个分镜。通过“类别”键分为两类：主分镜和过渡分镜。

        在上面的 JSON 中，漫画场景包含了三个特征：地形地貌和景物。地形指的是地球表面的高低起伏，包括山地、平地、盆地等，强调的是地面的形状和高度差异。地形信息主要在“场景”列中
        地貌指的是植被、水体等特征，包括森林、草原、湖泊、乡村、城镇、田地、道路等。地貌信息在“场景”列中体现的不明显，需要结合“场景”列和“内容描述”列来确定。
        景物指的是“房屋、车辆、人物”等比较小的物体，他们与地形相比，维度更微观。景物信息在“场景”列中有明显体现。但是“场景”列只提供了最核心的景物，需要补充更多的景物信息。
        
        我需要从中得到精细的 3D 漫画场景。这个过程将分步进行。让我们先专注于第一步：补充景物。
        你需要分析接下来提供的漫画分镜 JSON ，格式和上面的示例相同，然后对每一行的景物信息进行补充，以用作之后的3D场景建模。

        最后输出的格式：

        {
          "meta": "comic.prepare_scene",
          "scene": [
            {
                "类别": "主分镜",
                "画面": "对分镜画面内容的精确描述",
                "场景": "直接使用分镜格式中对应条目的location",
                "景物": ["场景中的景物"]
            },
            {
                "类别": "过渡分镜",
                "画面": "过渡的具体内容",
                "场景": "直接使用分镜格式中对应条目的location",
                "景物": "该字段不适用"
            }
          ]
        }

        相当于对原分镜JSON，删除“景别”，新增了“景物”，将“meta”的值改为“comic.prepare_scene”。
        
        内容要求：
        1、“类别”与“场景”字段与将要提供的分镜表格完全相同。
        2、对于“景物”字段，如果分镜类型是过渡分镜，则要填“该字段不适用”
        3、对于主分镜，你需要根据对应的场景、内容描述以及景别信息推断出该分镜包含的所有景物，然后输出到“景物”列。注意一定要全面，否则不利于生成精细的3D场景。
           举例：
            假如内容描述是“描绘小明站在窗前，眺望远方，眼神充满好奇。”，场景是“山地-乡村-小明的家-卧室”，景别是近景。
            所以你应该分析小明的卧室应该包含哪些景物，并且不用考虑其他房间是什么样的，因为这个分镜只涉及这一个房间。一般来说卧室中会有：一张床、一个书桌、一把椅子、一个衣柜、一扇窗户。
            你应该将这些景物以列表的形式输出到“景物”字段中。注意，人也是景物，所以不要忽略。特别是有名字的人。需要将“小明”也加入到“景物”中。

            假如内容描述是夕阳下的村庄格外美丽，场景是山地-乡村，景别是远景，可以看出这个分镜是整个乡村的远景，所以景物应该是：几栋房子、几辆车、田地。
        4、注意，景物一定是具体的，是不能再分的。例如上面的例子，景物不能是“乡村景色”。因为乡村景色是抽象的，它包括很多细节，比如路、树、房屋等。所以，你需要直接输出具体的景物。
            
        最终你应直接输出 JSON 内容，不要输出多余的文本。
    - role: "user"
      content: 提供的表格：@{prepare_scene.meta.param.sheet}
  meta:
    retriver_call: Null 
    model_args: Null
    param:
      sheet: Null
    output: 
      type: json_object
      schema:
        {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "type": "object",
          "properties": {
            "meta": {
              "type": "string"
            },
            "scene": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "类别": {
                    "type": "string",
                    "enum": ["主分镜", "过渡分镜"]
                  },
                  "画面": {
                    "type": "string"
                  },
                  "场景": {
                    "type": "string"
                  },
                  "景物": {
                    "oneOf": [
                      {
                        "type": "string"
                      },
                      {
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      }
                    ],
                    "nullable": true
                  }
                },
                "required": ["类别", "画面", "场景"],
                "additionalProperties": false
              }
            }
          },
          "required": ["meta", "scene"],
          "additionalProperties": false
        }
      parse_call: Null
# --------------------------------
refine_scene:
  message:
    - role: "system"
      content: |
        你的任务是分析一个漫画分镜表格，然后根据表格中的信息，设计出符合要求的 3D 漫画场景。
    - role: "system"
      content: |
        这是一个分镜与场景规划的 JSON 示例，其中“script”列表中的每个字典元素都代表一个分镜：

        {
          "meta": "comic.prepare_scene",
          "scene": [
            {
                "类别": "主分镜",
                "画面": "对分镜画面内容的精确描述",
                "场景": "分镜的场景信息",
                "景物": ["场景中的景物"]
            },
            {
                "类别": "过渡分镜",
                "画面": "过渡的具体内容",
                "场景": "分镜的场景信息",
                "景物": "该字段不适用"
            }
          ]
        }

        随后我将再提供一个分镜 JSON，格式与上面的表格相同，对于每个分镜字典你需要:
        1、对“景物”字段的内容进行优化：
          1、对于每个分镜，如果该字段包含抽象、模糊的概念，例如景色、风景，则需要把这些概念进行拆分成不可分的物体。与光线相关的物体，例如光影、光影效果，需要删掉。
          2、对于每个分镜，你还需要视情况对该列的内容进行补充，使其内容更为详细。注意补充的内容一定是具象的物体。
          3、最终你需要确保“景物”列中的景物全部是具象的物体名称。
          4、注意，景物字段的类型是列表。
        2、在“场景”字段的下边增加一个字段“封闭性”：
          1、对于每个分镜，你需要判断该分镜所在的场景是否是封闭的，如果是，则将“封闭性”列的值设为“封闭”，否则设为“开放”。
          2、封闭性的判断标准：凡是四周被阻挡，顶部被大部分遮挡的都是封闭空间，例如洞穴、室内。顶部露天的都是开放空间，例如城市、峡谷等
          3、对于过渡分镜，一律设为“该字段不适用”。
        3、其他的列不需要改动。

        针对上面的表格示例，处理后的表格如下：

        {
          "meta": "comic.refine_scene",
          "refined_scene": [
            {
                "类别": "主分镜",
                "画面": "对分镜画面内容的精确描述",
                "场景": "分镜的场景信息",
                "封闭性": "封闭或者开放", 
                "景物": ["优化后的景物信息"]
            },
            {
                "类别": "过渡分镜",
                "画面": "过渡的具体内容",
                "场景": "分镜的场景信息",
                "封闭性": "封闭或者开放",
                "景物": "该字段不适用"
            }
          ]
        }

        请直接按照格式输出 JSON ，不要输出多余的文字。
    - role: "user"
      content: 提供的表格：@{refine_scene.meta.param.sheet}
  meta:
    retriver_call: Null 
    model_args: Null
    param:
      sheet: Null
    output: 
      type: json_object   
      schema:
        {
          "$schema": "http://json-schema.org/draft-07/schema#",
          "type": "object",
          "properties": {
            "meta": {
              "type": "string"
            },
            "refined_scene": {
              "type": "array",
              "items": {
                "type": "object",
                "properties": {
                  "类别": {
                    "type": "string",
                    "enum": ["主分镜", "过渡分镜"]
                  },
                  "画面": {
                    "type": "string"
                  },
                  "场景": {
                    "type": "string"
                  },
                  "封闭性": {
                    "type": "string",
                    "enum": ["封闭", "开放", "该字段不适用"]
                  },
                  "景物": {
                    "oneOf": [
                      {
                        "type": "string"
                      },
                      {
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      }
                    ],
                    "nullable": true
                  }
                },
                "required": ["类别", "画面", "场景", "封闭性"],
                "additionalProperties": false
              }
            }
          },
          "required": ["meta", "refined_scene"],
          "additionalProperties": false
        }
      parse_call: Null































